<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>PaddleDetection(一)</title>
    <link href="/2022/04/19/PaddleDetection(%E4%B8%80)/"/>
    <url>/2022/04/19/PaddleDetection(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="PaddleDetection（一）"><a href="#PaddleDetection（一）" class="headerlink" title="PaddleDetection（一）"></a>PaddleDetection（一）</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>亲测有效</p></blockquote><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Linux 18.04 </p><p>cuda10.1 </p><p>python3.6</p><h3 id="安装说明"><a href="#安装说明" class="headerlink" title="安装说明"></a>安装说明</h3><ol><li><p>安装PaddlePaddle</p> <figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># CUDA10.1</span><br>python -m pip install paddlepaddle-gpu==2.2.0.post101 -f https://www.paddlepaddle.org.cn/whl/linux/mkl/avx/stable.html<br></code></pre></td></tr></table></figure><p> 使用以下命令进行验证</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在您的Python解释器中确认PaddlePaddle安装成功</span><br>&gt;&gt;&gt; import paddle<br>&gt;&gt;&gt; paddle.utils.run_check()<br><br><span class="hljs-comment"># 确认PaddlePaddle版本</span><br>python -c <span class="hljs-string">&quot;import paddle; print(paddle.__version__)&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>安装PaddleDetection</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 克隆PaddleDetection仓库</span><br><span class="hljs-built_in">cd</span> &lt;path/to/clone/PaddleDetection&gt;<br>git <span class="hljs-built_in">clone</span> https://github.com/PaddlePaddle/PaddleDetection.git<br><br><span class="hljs-comment"># 安装其他依赖</span><br><span class="hljs-built_in">cd</span> PaddleDetection<br>pip install -r requirements.txt<br><br><span class="hljs-comment"># 编译安装paddledet</span><br>python setup.py install<br></code></pre></td></tr></table></figure><p> 安装后确认测试通过：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python ppdet/modeling/tests/test_architectures.py<br></code></pre></td></tr></table></figure><p> 测试通过后会提示如下信息：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">.......<br>----------------------------------------------------------------------<br>Ran 7 tests <span class="hljs-keyword">in</span> 12.816s<br>OK<br></code></pre></td></tr></table></figure></li></ol><h2 id="快速体验"><a href="#快速体验" class="headerlink" title="快速体验"></a>快速体验</h2><p><strong>恭喜！</strong> 您已经成功安装了PaddleDetection，接下来快速体验目标检测效果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在GPU上预测一张图片</span><br><span class="hljs-built_in">export</span> CUDA_VISIBLE_DEVICES=0<br>python tools/infer.py -c configs/ppyolo/ppyolo_r50vd_dcn_1x_coco.yml -o use_gpu=<span class="hljs-literal">true</span> weights=https://paddledet.bj.bcebos.com/models/ppyolo_r50vd_dcn_1x_coco.pdparams --infer_img=demo/000000014439.jpg<br></code></pre></td></tr></table></figure><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220419145341304.png" alt="image-20220419145341304" style="zoom:80%;" />]]></content>
    
    
    <categories>
      
      <category>安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <link href="/2022/04/15/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2022/04/15/Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建Hexo"><a href="#搭建Hexo" class="headerlink" title="搭建Hexo"></a>搭建Hexo</h1><h2 id="第一步：安装node-js与Git"><a href="#第一步：安装node-js与Git" class="headerlink" title="第一步：安装node.js与Git"></a>第一步：安装node.js与Git</h2><blockquote><p>Hexo基于Node.js，搭建过程中需要使用npm(Node.js已带)和git，因此先搭建本地操作环境，安装Node.js和Git</p></blockquote><h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>官网安装：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220415164349000.png" alt="image-20220415164349000" style="zoom:70%;" /><ul><li>根据自己的需求下载安装包，傻瓜式一路点”下一步</li></ul><p>安装完成后，按<code>Win+R</code>打开命令提示符，依次输入<code>node -v</code>,<code>npm -v</code>,如下图出现程序版本号表示安装完成</p><p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220415164734919.png" alt="image-20220415164734919"></p><blockquote><p>为npm添加镜像源，按<code>Win+R</code>打开命令提示符</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>官网安装：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>傻瓜式安装对应版本，在安装完成之后在开始菜单有5个图标</p><p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/564d6bbd20e24cb09612ac68b6141a99.png" alt="img"></p><p>安装完成后，在cmd中，输入<code>git --version</code>，出现程序版本号表示安装完成</p><h2 id="第二步：本地安装Hexo博客"><a href="#第二步：本地安装Hexo博客" class="headerlink" title="第二步：本地安装Hexo博客"></a>第二步：本地安装Hexo博客</h2><p>新建一个空文档如MyBlog，在当前路径下打开命令提示符，输入以下命令</p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>使用npm一键安装Hexo</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><h3 id="Hexo初始化和本地预览"><a href="#Hexo初始化和本地预览" class="headerlink" title="Hexo初始化和本地预览"></a>Hexo初始化和本地预览</h3><ul><li><p>初始化并安装所需组件</p>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span>  <span class="hljs-meta">#这个表示在当前文件夹下初始化</span><br>hexo <span class="hljs-keyword">init</span> blog <span class="hljs-meta">#表示在子文件blog下初始化</span><br></code></pre></td></tr></table></figure><p>  <img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220415170120102.png" alt="image-20220415170120102"></p></li><li><p>本地化预览，测试我们搭建的网站雏形</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">hexo</span> g   <span class="hljs-comment"># 生成页面</span><br>hexo s   <span class="hljs-comment"># 启动预览</span><br></code></pre></td></tr></table></figure><p>  访问<a href="http://localhost:4000/%EF%BC%8C%E5%87%BA%E7%8E%B0Hexo%E9%BB%98%E8%AE%A4%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F">http://localhost:4000/，出现Hexo默认页面，本地博客安装成功</a></p><p>  <img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220415171104504.png" alt="image-20220415171104504"></p></li></ul><p>Tips:如果出现页面加载不出来，可能是端口被占用了，Ctrl+C关闭服务器，运行<code>hexo server -p 5000  </code>更换端口号试试</p><h2 id="第三步更换主题"><a href="#第三步更换主题" class="headerlink" title="第三步更换主题"></a>第三步更换主题</h2><blockquote><p>这里选用fluid主题</p><p>更多好看的主题在<a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a></p></blockquote><ul><li><p>第一步：安装主题</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure></li><li><p>第二步：在博客目录下创建 <code>_config.fluid.yml</code>文件</p><p>  <img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220415205833716.png" alt="image-20220415205833716"></p></li><li><p>第三步：将<code>博客根目录\node_modules\hexo-theme-fluid\_config.yml  </code>中内容复制到_config.fluid.yml</p></li><li><p>第四步：如下修改 Hexo 博客目录中的 <code>_config.yml</code>：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure></li><li><p>第五步：<code>hexo g</code> <code>hexo s</code>查看一下</p></li><li><p>第六步：根据自己需求设计主题内容，详见<a href="https://fluid-dev.github.io/hexo-fluid-docs/start/">https://fluid-dev.github.io/hexo-fluid-docs/start/</a></p></li></ul><h1 id="部署Hexo到Github"><a href="#部署Hexo到Github" class="headerlink" title="部署Hexo到Github"></a>部署Hexo到Github</h1><h2 id="在GitHub新建一个仓库"><a href="#在GitHub新建一个仓库" class="headerlink" title="在GitHub新建一个仓库"></a>在GitHub新建一个仓库</h2><p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220416181705976.png" alt="image-20220416181705976"></p><h2 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h2><p>打开git bash，然后输入下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;你GitHub用户名&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;你Github邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>然后生成密钥SSH key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;你Github邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>打开Github，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220416182509472.png" alt="image-20220416182509472" style="zoom:80%;" /><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220416182722717.png" alt="image-20220416182722717" style="zoom:70%;" /><p>git bash中输入:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure><p>将输出的内容复制到框中，点击确定保存。</p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220416194916184.png" alt="image-20220416194916184" style="zoom:67%;" /><p>输入<code>ssh -T git@github.com</code>，如果如下图所示，出现你的用户名，那就成功了。</p><p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220416183029132.png" alt="image-20220416183029132"></p><p>打开博客根目录下的<code>_config.yml</code>文件，这是博客的配置文件，在这里你可以修改与博客相关的各种信息。</p><p>修改最后一行的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">deploy:<br>  <span class="hljs-built_in">type</span>: <span class="hljs-string">&#x27;git&#x27;</span><br>  repo: https://github.com/377fsq/377fsq.github.io.git  <span class="hljs-comment"># 修改为你自己的github项目地址</span><br>  branch: main<br></code></pre></td></tr></table></figure><p>安装Git部署插件，输入命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basemake">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>在分别输入三条命令：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean </span><br><span class="hljs-attribute">hexo g </span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>然后就完成啦！！！这时打开你的github.io主页就能看到发布的文章啦！！！</p>]]></content>
    
    
    <categories>
      
      <category>安装</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安装教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java-基础知识</title>
    <link href="/2022/04/15/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/04/15/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-数据类型分为两类"><a href="#Java-数据类型分为两类" class="headerlink" title="Java 数据类型分为两类"></a>Java 数据类型分为两类</h2><ul><li><p>基本类型</p>  <figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//整数</span><br><span class="hljs-type">int</span> num1= <span class="hljs-number">20</span>;<br><span class="hljs-type">byte</span> num2=<span class="hljs-number">20</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">num3</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">num4</span> <span class="hljs-operator">=</span> <span class="hljs-number">40L</span>;<br><br><span class="hljs-comment">//小数</span><br><span class="hljs-type">float</span> <span class="hljs-variable">num5</span> <span class="hljs-operator">=</span> <span class="hljs-number">50.1F</span>;<span class="hljs-comment">//Lfloat类型一定要在数字后面加个F</span><br><span class="hljs-type">double</span> <span class="hljs-variable">num6</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.1415926344365467687685</span>;<br><br><span class="hljs-comment">//字符</span><br><span class="hljs-type">char</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;中&#x27;</span>;<span class="hljs-comment">//用单引号</span><br><span class="hljs-comment">//字符串String不是关键字 是类</span><br><span class="hljs-comment">//String name = &quot;中国&quot;;//用双引号</span><br><br><span class="hljs-comment">//布尔值</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//或者true</span><br></code></pre></td></tr></table></figure></li><li><p>引用类型（除了基本类型之外其他都是引用类型）</p><ol><li>类</li><li>接口</li><li>数组</li></ol></li></ul><hr><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//整数拓展</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<span class="hljs-comment">//output==10</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">010</span>; <span class="hljs-comment">//八进制 0   output==8</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i3</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x10</span>;<span class="hljs-comment">//十六进制 0x  0~9 A~F  output==16 </span><br><br><span class="hljs-comment">//浮点数拓展</span><br><span class="hljs-comment">//算钱不能用float 和 double</span><br><span class="hljs-comment">//float：有限 离散 舍入误差  接近但不等于</span><br><span class="hljs-comment">//少用浮点数进行比较</span><br><span class="hljs-comment">//金钱使用 BigDecimal 数学工具类</span><br><br><br><span class="hljs-comment">//字符拓展</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)c1;<span class="hljs-comment">//强制转换==97 ASCII码</span><br><span class="hljs-comment">//所有的字符本质还是数字</span><br><span class="hljs-comment">//编码 Unicode 表：（97=a 65=A）</span><br><br><span class="hljs-comment">//转义字符</span><br><span class="hljs-comment">//\t 制表符</span><br><span class="hljs-comment">//\n 换行</span><br><span class="hljs-comment">//。。。</span><br></code></pre></td></tr></table></figure><hr><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li>强制转换 (类型)变量名 高-&gt;低</li><li>自动转换 低-&gt;高</li><li>注意点：<ol><li>不能对布尔值进行转换</li><li>不能把对象类型转换为不相干的类型</li><li>再把高容量转换到低容量，强制转换</li><li>转换的时候可能存在内存溢出，或者精度问题</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println((<span class="hljs-type">int</span>)<span class="hljs-number">23.7</span>);<span class="hljs-comment">//23</span><br>System.out.println((<span class="hljs-type">int</span>)-<span class="hljs-number">45.89f</span>);<span class="hljs-comment">//-45</span><br><br>System.out.println((<span class="hljs-type">char</span>)<span class="hljs-number">97</span>);<span class="hljs-comment">//a</span><br><br><span class="hljs-comment">//jdk7新特性，数字之间可以用下划线分割 下划线并不会被输出</span><br><span class="hljs-type">int</span> <span class="hljs-variable">money</span> <span class="hljs-operator">=</span> <span class="hljs-number">10_0000_0000</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> money*year;<span class="hljs-comment">//-1474836480 计算的时候溢出了 </span><br><span class="hljs-comment">//解决</span><br><span class="hljs-type">long</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> money*((<span class="hljs-type">long</span>)year);<br><br></code></pre></td></tr></table></figure><hr><h2 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Variable</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">allclicks</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//类变量（随着类一起出现一起消失）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span>; <span class="hljs-comment">// 实例变量，从属于对象（方法外面 类里面）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//局部变量，只能在方法里面用</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>变量命名规则</p><ol><li>类成员变量：首字母小写和驼峰规则 -&gt;monthSalary 除了第一个单词后面字母首字母大写</li><li>局部变量：首字母小写和驼峰规则</li><li>常量：大写字母和下划线： MAX_VALUE</li><li>类名：首字母大写和驼峰规则-&gt;Man，GoodMan</li><li>方法名：首字母小写和驼峰规则-&gt;run()，runRun()</li></ol><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>位运算符&lt;&lt;  表示*2  例子2&lt;&lt;3&#x3D;16  转换为2进制理解</p><p>​                &gt;&gt; 表示&#x2F;2 </p><hr><h2 id="Java-Doc"><a href="#Java-Doc" class="headerlink" title="Java Doc"></a>Java Doc</h2><ul><li><p>参数信息</p><p>  @author 作者名<br>  @version 版本号<br>  @since 指明需要最早使用的jdk版本</p><p>  @param 参数名</p><p>  @return 返回值情况</p><p>  @throws 异常抛出情况</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*@author fsq</span><br><span class="hljs-comment">*@version 1.0</span><br><span class="hljs-comment">*@since 1.8</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> class 类名&#123;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    @param 参数名</span><br><span class="hljs-comment">@return 返回值情况</span><br><span class="hljs-comment">@throws 异常抛出情况</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> String 方法名(String 参数名) <span class="hljs-keyword">throws</span> Exception&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>怎么生成Doc文档?</p><p>在命令行执行: javadoc -encoding UTF-8 -charset UTF-8 Doc.java</p><hr><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="Scanner对象"><a href="#Scanner对象" class="headerlink" title="Scanner对象"></a>Scanner对象</h2><p>我们可以通过scanner类来获取用户的输入</p><p>基本语法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;用next方法接收&quot;</span>);<br><span class="hljs-keyword">if</span> (s.hasNext())<br>&#123;<br>String str= s.next();<br>System.out.println(<span class="hljs-string">&quot;输出内容:&quot;</span>+str);<br>&#125;<br>    <span class="hljs-comment">//凡是io流的类如果不关闭会一直占用资源.要养成习惯关闭</span><br>s.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>通过Scanner类的next()与nextLine() 方法获取输入的字符串</p><p>在读取前我们一般需要使用hasNext() 与hasNextLine()判断是否还有输入的数据</p><ul><li>next 以空格为结束</li><li>nextline 以空格为结束</li><li>如果是输入其他类型 比如整数  那就scanner.nextInt(); 其他类似</li></ul><hr><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><ul><li>设计规则 一个方法只做一个功能</li></ul><p>方法的命名规则:首字母小写驼峰规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>System.out.println(add(a,b));<br>&#125;<br><span class="hljs-comment">//加法 添加关键字static 在main方法使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br><span class="hljs-keyword">return</span> a+b;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>Java 方法类似于其他语言的函数</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">修饰符 返回值类型 方法名(参数类型 参数名)<br>&#123;<br>    ...<br>    方法体<br>    ...<br>    <span class="hljs-keyword">return</span> 返回值<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>java是值传递</p></li></ul><hr><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p><em><strong>规则</strong></em></p><ul><li>方法名必须相同</li><li>参数列表必须不同</li><li>编译器会根据参数类型个数自动匹配</li></ul><hr><h2 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//编译</span><br>javac 名字.java<br><br><span class="hljs-comment">//会生成同名.class文件</span><br>java 名字<br><br>    <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; args.length; i++)<br>    &#123;<br>        System.out.println(args[i]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>在方法声明中,在指定参数类型后加一个省略号(…)</li><li>一个方法只能指定一个可变参数,它必须是方法的最后一个参数</li><li>不确定要传多少个参数的时候用</li></ul><hr><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>递归就是A方法调用A方法</li><li>递归包括两个部分<ol><li>递归头:什么时候不调用自身的方法,如果没有头,将陷入死循环</li><li>递归体:什么时候需要调用自身方法</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-comment">//5! 5*4*3*2*1</span><br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> n*fun(n-<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//定义一个二维数组</span><br><span class="hljs-type">int</span>[][] array = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>例子：冒泡排序</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//比较数组中两个相邻的元素</span><br><span class="hljs-comment">//如果第一个数比第二个数大,则交换位置</span><br><span class="hljs-comment">//每一次比较,都会产生一个最大,或者一个最小的数字</span><br><span class="hljs-type">int</span>[] a = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9090</span>,<span class="hljs-number">2345</span>,<span class="hljs-number">677</span>,<span class="hljs-number">875</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> a.length-<span class="hljs-number">1</span>;<br><span class="hljs-comment">// 冒泡排序</span><br><span class="hljs-comment">//外层循环 判断要走多少次</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i&lt; a.length-<span class="hljs-number">1</span>;i++)<br>&#123;<br><span class="hljs-comment">//优化 如果已经有序 那就不用再循环遍历一次了 减少没有意义比较</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 内层循环比较两个数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;a.length-<span class="hljs-number">1</span>-i;j++)&#123;<br><span class="hljs-keyword">if</span> (a[j+<span class="hljs-number">1</span>]&lt;a[j])<br>&#123;<br><span class="hljs-comment">// 交换数字</span><br><span class="hljs-comment">//int temp = a[j];</span><br><span class="hljs-comment">//a[j] = a[j+1];</span><br><span class="hljs-comment">//a[j+1]=temp;</span><br><br><span class="hljs-comment">//交换方法2</span><br>a[j]^=a[j+<span class="hljs-number">1</span>];<br>a[j+<span class="hljs-number">1</span>]^=a[j];<br>a[j]^=a[j+<span class="hljs-number">1</span>];<br>flag = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag==<span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-comment">//没有进行比较 就不用循环了</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>System.out.println(Arrays.toString(a));<br></code></pre></td></tr></table></figure><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>需求: 编写五子棋游戏中,有存盘退出和续上盘的功能</p><p>当一个数组中大部分元素为0,或者为同一值数组时,可以引用稀疏数组来保存该数组.</p><ul><li>处理方式<ol><li>记录数组一共有几列几行,有多少个不同的值</li><li>把具有不同值的元素和行列及值记录在一个小规模的数组中,从而缩小程序的规模</li></ol></li></ul><p>简单来说就是把不一样的值单独拎出来组合 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">// 1 创建一个二维数组11*11 0 表示没有棋子 1表示黑棋 2表示白棋</span><br><span class="hljs-type">int</span>[][] array1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">11</span>][<span class="hljs-number">11</span>];<br>array1[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]=<span class="hljs-number">1</span>;<br>array1[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">2</span>;<br><br>System.out.println(<span class="hljs-string">&quot;输出原始的数组&quot;</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>[] ints:array1)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> anInt:ints)<br>&#123;<br>System.out.print(anInt+<span class="hljs-string">&#x27;\n&#x27;</span>);<br>&#125;<br>System.out.println();<br>&#125;<br><br><span class="hljs-comment">// 创建一个稀疏数组</span><br><span class="hljs-comment">//转换稀疏数组保存</span><br><span class="hljs-comment">//获取有效值个数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">11</span>;i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">11</span>;j++)<br>&#123;<br><span class="hljs-keyword">if</span> (array1[i][j]!=<span class="hljs-number">0</span>)<br>&#123;<br>sum++;<br>&#125;<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;有效个数&quot;</span>+sum);<br><span class="hljs-type">int</span>[][] array2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[sum+<span class="hljs-number">1</span>][<span class="hljs-number">3</span>];<br>array2[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">11</span>;<br>array2[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">11</span>;<br>array2[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>]=sum;<br><span class="hljs-comment">//遍历二维数组,将非零的值,存放稀疏数组中</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; array1.length;i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>; j&lt; array1[i].length;j++)<br>&#123;<br><span class="hljs-keyword">if</span> (array1[i][j]!=<span class="hljs-number">0</span>)<br>&#123;<br>count++;<br>array2[count][<span class="hljs-number">0</span>]=i;<br>array2[count][<span class="hljs-number">1</span>]=j;<br>array2[count][<span class="hljs-number">2</span>]=array1[i][j];<br>&#125;<br>&#125;<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;稀疏数组&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;array2.length;i++)<br>&#123;<br>System.out.println(array2[i][<span class="hljs-number">0</span>]+<span class="hljs-string">&quot;\t&quot;</span>+<br>array2[i][<span class="hljs-number">1</span>]+<span class="hljs-string">&quot;\t&quot;</span>+<br>array2[i][<span class="hljs-number">2</span>]+<span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><blockquote><p><em><strong>分类</strong></em>的思维模式</p></blockquote><p>思考问题首先会解决问题需要哪些分类,然后进行单独思考</p><ul><li><p><strong>宏观</strong>上,从整体分析.需要面向对象的思路</p></li><li><p>微观上,仍需要面向过程的思路处理</p></li></ul><p><strong>面向对象编程的本质就是：以类的方式组织代码，以对象的组织（封装）数据</strong></p><p>三大特性</p><ol><li>封装</li><li>继承</li><li>多态</li></ol><p>oop:面向编程</p><hr><h2 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> &#123;<br>    <span class="hljs-comment">//属性 : 字段</span><br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.name+<span class="hljs-string">&quot;在学习&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//s 就是student类的具体实例</span><br>    <span class="hljs-comment">// 通过new 创造不同的实例</span><br><span class="hljs-type">student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">student</span>();<br>s.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>    s.age = <span class="hljs-number">3</span>;<br>s.study();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul><li><p>一个类即使什么都不写 系统也会默认生成一个构造函数</p></li><li><p>特点</p><ol><li>名字和类名相同</li><li>没有返回值 也不写void</li></ol></li><li><p>总结</p><ol><li>构造器一般用来实例化初始值</li><li>使用new关键字,必须要有构造器  –&gt;new本质就是调用构造器</li><li>可以是有参构造和无参构造  一旦定义有参构造,无参构造就必须显示定义否则就无效</li><li>快捷键 alt+insert 一键生成构造函数</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-comment">// 构造方法 1 名字和类名相同 2 没有返回值类型 也不写void</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">//有参构造 使用有参构造上面的无参构造就要写出来</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;张三&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="类与对象总结"><a href="#类与对象总结" class="headerlink" title="类与对象总结"></a>类与对象总结</h2><ol><li><p>类与对象 </p><p> 类是一个模板:抽象 </p><p> 对象是一个具体的实例</p></li><li><p>方法 </p><p> 定义、调用</p></li><li><p>对应的引用</p><p> 引用类型：基本类型（8） </p><p> 对象是通过引用来操作的：栈—》堆</p></li><li><p>属性：字段&#x2F;变量&#x2F;成员变量  </p><p> 默认初始化  </p><p> 数字：0 </p><p> char:u000</p><p> boolean:false</p><p> 引用：null</p></li><li><p>对象的创建和使用   </p><ul><li>必须使用 new关键字构造对象  构造函数</li><li>对象的属性</li><li>对象的方法</li></ul></li><li><p>类:</p><p> 静态的属性 动态的方法</p></li></ol><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li><p>程序追求“高内聚 低耦合”</p><p>  高内聚：类的内部数据操作细节自己完成，不允许外部干涉</p><p>  低耦合：仅暴露少量方法给外部使用</p></li><li><p>封装主要是针对属性</p></li><li><p>记住 ： 属性私有 get&#x2F;set</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> sex;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-comment">//给属性提供可以操作的方法</span><br>    <span class="hljs-comment">//提供 public 的 get 和 set 方法</span><br>    <span class="hljs-comment">//name</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//sex</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span> <span class="hljs-title function_">getSex</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.sex;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSex</span><span class="hljs-params">(<span class="hljs-type">char</span> sex)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (sex==<span class="hljs-string">&#x27;女&#x27;</span> || sex==<span class="hljs-string">&#x27;男&#x27;</span>)&#123;<br>        <span class="hljs-built_in">this</span>.sex = sex;&#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;性别输入不合法&quot;</span>);<br><span class="hljs-comment">//            this.sex = &#x27;男&#x27;;</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//age</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>( <span class="hljs-number">0</span>&lt;=age &amp;&amp; age&lt;=<span class="hljs-number">100</span> )&#123;<br>        <span class="hljs-built_in">this</span>.age = age;&#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.age = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>  调用</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//使用new关键字 实例化一个对象</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>person.setSex(<span class="hljs-string">&#x27;你&#x27;</span>);<br>person.setAge(<span class="hljs-number">999</span>);<br>System.out.println(person.getName());<br>System.out.println(person.getSex());<br>System.out.println(person.getAge());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>作用<ol><li>提高程序的安全性，保护数据</li><li>隐藏代码的实现细节</li><li>同一接口</li><li>系统可维护性增加了</li></ol></li></ul></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li><p>继承的本质是对某一批类的抽象，从而实现更好的建模</p></li><li><p>extands的意思是”扩展”,子类是父类的扩展</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//父类</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br> &#125;<br><span class="hljs-comment">// 子类/派生类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Person</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Java只有单继承没有多继承</strong>(一个儿子只能由一个爸爸 )</p></li><li><p>继承是类和类之间的关系</p></li><li><p>object类</p></li><li><p>super</p><ol><li><p>super 调用的是父类的构造方法,必须在构造方法的第一个</p></li><li><p>super必须只能出现在子类的方法或构造方法中</p></li><li><p>super 和 this不能同时调用构造方法</p></li><li><p>super vs this</p><ul><li><p>代表对象不同:</p><p>  this 本身调用者这个对象</p><p>  super 代表父类对象的应用</p></li><li><p>前提不同</p><p>  this 没有继承也可以使用</p><p>  super 只能在继承条件才可以使用</p></li><li><p>构造方法不同</p><p>  this() 本类的构造</p><p>  super() 父类的构造</p></li></ul></li></ol></li><li><p>方法重写</p><ol><li><p>重写都是方法的重写和属性无关</p></li><li><p>需要有继承关系,子类重写父类的方法</p><ul><li>方法名必须相同</li><li>参数列表必须相同</li><li>修饰符:返回可以扩大,但不能缩小 public &gt; protected&gt;default&gt;private</li><li>抛出的异常:范围可以被缩小,但不能扩大</li></ul></li><li><p>为什么需要重写?</p><p> 子类不一定需要,或者不一定满足</p></li></ol></li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol><li>多态存在条件</li></ol><div class="code-wrapper"><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">//可以指向的引用类型就不确定了;父类的引用指向子类</span><br><span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-type">Person</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">student3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br></code></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>多态是方法的多态,属性没有多态</p></li><li><p>父类和子类,有联系  类型转换异常</p></li><li><p>存在的条件:</p></li></ol><div class="code-wrapper"><pre><code class="hljs">继承关系 方法需要重写(static 不能被重写属于类   final 修饰也不行属于常量   private也不能重写私有的)父类引用指向子类对象  Father f1 = new Son();</code></pre></div><ol start="5"><li>多态是方法的多态,属性没有多态</li></ol><ul><li><p>instanceof </p><p>  类判断</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>System.out.println(object <span class="hljs-keyword">instanceof</span> Person);<br>                 <span class="hljs-comment">// 父辈类              子类</span><br>&gt;&gt;返回<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li><p>类转换</p><ol><li>父类引用指向子类的对象</li><li>把子类转换为父类，向上转型</li><li>把父类转换为子类，向下转型，强制转换</li></ol></li><li><p>子类可以调用父类的public属性 和方法(方法一般都是public)</p></li><li><p>static 关键字详解</p><ol><li><p>用在属性-》静态变量</p></li><li><p>用在方法-》静态方法</p></li><li><p>静态方法块</p></li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;  <br>    <span class="hljs-comment">//2第二个执行</span><br>&#123;<br>        System.out.println(<span class="hljs-string">&quot;匿名代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//1先执行:且执行一次 再new一个对象就不执行了</span><br>    <span class="hljs-keyword">static</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;静态代码块&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//3第三个执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;构造方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li><p>静态导入包</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> 类.静态方法<br></code></pre></td></tr></table></figure></li></ol></li><li><p>快捷键 CTRL+h,看继承树    <strong>所有的类都直接或者间接的继承object类</strong></p><p>  <img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220415161750806.png" alt="image-20220415161750806"></p></li></ul><hr><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul><li><p>用abstract修饰</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.demo;<br><span class="hljs-comment">//extends 是单继承  但是怎么才能多继承:接口可以多继承</span><br><span class="hljs-comment">//添加一个abstract修饰词 就变成了 抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-comment">//约束~有人帮我们实现</span><br>    <span class="hljs-comment">//abstract 抽象方法 只有方法名字 没有方法实现</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    * 1 不能new这个抽象类 只能靠子类实现它: 约束~</span><br><span class="hljs-comment">    * 2 抽象类中可以写普通方法</span><br><span class="hljs-comment">    * 3 抽象方法必须再抽象类中</span><br><span class="hljs-comment">    * 存在的意义 : 提高开发的效率</span><br><span class="hljs-comment">    * */</span><br>&#125;<br><br><br><span class="hljs-keyword">package</span> test.demo;<br><span class="hljs-comment">//抽象类的所有方法: 继承了他的子类,都必须实现它的所有方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Action</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;实现抽象方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li><p>普通类：只有具体实现</p></li><li><p>抽象类：具体实现和规范（抽象方法）都有！</p></li><li><p>接口：只有规范！自己无法写方法，专业的约束，实现约束和实现分离</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//接口1</span><br><span class="hljs-keyword">package</span> test.demo;<br><br><span class="hljs-comment">//interface 接口定义关键字   接口都需要实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-comment">//也可以定义常量(接口类中的属性是常量)  默认修饰词 public static final</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>; <span class="hljs-comment">//一般不用  通常接口都是定义方法</span><br>    <span class="hljs-comment">// 接口中的所有定义其实都是抽象的 修饰词牧人是public abstract</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">del</span><span class="hljs-params">(String name)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String name)</span>;<br>&#125;<br><br><span class="hljs-comment">//接口2</span><br><span class="hljs-keyword">package</span> test.demo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TimeService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">time</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//实现</span><br><span class="hljs-keyword">package</span> test.demo;<br><br><span class="hljs-comment">//接口实现类 一般用Impl结尾  关键词implements 后面接要实现的接口类</span><br><span class="hljs-comment">//抽象类 extends ~</span><br><span class="hljs-comment">//类 可以实现接口 implements 接口</span><br><span class="hljs-comment">//实现了接口的类 就需要重写接口中的方法</span><br><span class="hljs-comment">//利用接口实现多继承</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span>,TimeService&#123;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">//重写的注释</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">del</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String name)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">time</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>总结</p><p>  作用</p><ol><li>约束</li><li>定义一些方法 让不同的人实现</li><li>方法都是 public abstract</li><li>属性都是public static final</li><li>接口不能被实例化 接口中没有构造方法</li><li>implements可以实现多个接口</li><li>必须要重写接口中的方法</li></ol></li></ul><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>就是指一个类内部在定义一个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> test.demo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Outer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id=<span class="hljs-number">666</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">out</span><span class="hljs-params">()</span><br>    &#123;<br>        System.out.println(<span class="hljs-string">&quot;这是外部类的方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">in</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;这是内部类的方法&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 内部类可以访问外部类的私有属性 私有方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span><br>        &#123;<br>            System.out.println(<span class="hljs-string">&quot;private id&quot;</span>+id);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Outer</span> <span class="hljs-variable">outer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outer</span>();<br><span class="hljs-comment">//通过外部类来实例化内部类</span><br>Outer.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outer.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>inner.getId();<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="异常机制"><a href="#异常机制" class="headerlink" title="异常机制"></a>异常机制</h1><ul><li><p>Exception:</p><p>  意思是例外，或者是异常</p><p>  error 通常是灾难性的致命的错误</p></li><li><p>捕获和抛出异常</p><ol><li><p>异常处理五个关键字</p><p> try、catch、finally、throw、throws</p><p> throwable 是最高级的错</p><p> catch（想要捕获的类型）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//监控区域</span><br>System.out.println(a/b);<br>&#125;<span class="hljs-keyword">catch</span> (ArithmeticException e) &#123;<span class="hljs-comment">//捕获异常 可以不要finally 但一定要catch</span><br>System.out.println(<span class="hljs-string">&quot;出现异常 分子不能为0&quot;</span>);<br>&#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//一般用来处理善后工作 无论是否有异常都会执行 用处:例如处理io流的关闭操作</span><br>System.out.println(<span class="hljs-string">&quot;finally&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>主动抛出异常</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//主动抛出异常 throw throws</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArithmeticException</span>();<span class="hljs-comment">// 一般在方法中使用</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> <span class="hljs-keyword">throws</span> ArithmeticException&#123; 方法上抛出异常<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>快捷键</p><ol><li><p>psvm 生成main函数</p></li><li><p>CTRL+alt+t 选择代码块</p></li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>工作</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ViTDet</title>
    <link href="/2022/04/12/ViTDet/"/>
    <url>/2022/04/12/ViTDet/</url>
    
    <content type="html"><![CDATA[<h1 id="ViTDet"><a href="#ViTDet" class="headerlink" title="ViTDet"></a>ViTDet</h1><blockquote><p>视觉领域Transformer骨干</p></blockquote><h2 id="一句话总结"><a href="#一句话总结" class="headerlink" title="一句话总结"></a>一句话总结</h2><p>将普通 ViT 主干预训练为<strong>MAE</strong>，检测器 ViTDet 可以与之前所有基于分层主干的领先方法竞争，仅使用 ImageNet-1K预训练在 COCO上可达到 61.3 box AP！代码将开源！</p><ul><li>MAE是使用类似于BERT的掩码机制，从图片中随机抹去一些像素，并让模型通过已知像素去构建未知像素，从而迫使模型学习图像中的特征。</li></ul><h2 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h2><p>“We explore the plain, non-hierarchical Vision Transformer (ViT) as a backbone network for object detection.” (Li 等。, 2022, p. 1)</p><ul><li>以最普通的，非层级结构的ViT作为Baseline改进。</li><li>基于ViT设计一个针对目标检测任务的通用骨干。</li></ul><p>本文主要目标是消除骨干网络中的分层结构约束，主要探索一种适用于目标检测的普通骨干网络。</p><h2 id="二、引言"><a href="#二、引言" class="headerlink" title="二、引言"></a>二、引言</h2><ul><li><p>第一段，拆分检测网络结构backbone+neck+head</p><p>  引出问题：</p><p>  “For a long while, these backbones have been multi-scale, hierarchical architectures due to the de facto design of convolutional networks (ConvNet) [31], which has heavily influenced the neck&#x2F;head design for detecting objects at multiple scales (e.g., FPN).” (Li 等。, 2022, p. 1)</p><p>  卷积网络的backbone大多都是<strong>多尺度</strong>设计，这严重影响了neck&#x2F;head的设计</p></li><li><p>第二段，引出“Vision Transformers (ViT)”</p><p>  ViT相对卷积网络的不同（主要是针对第一段问题展开）：原始的ViT是一种普通的、非分层的结构。满足极简架构的需求。</p><p>  引出问题：</p><p>  “How can we address multi-scale objects in a downstream task with a plain backbone from upstream pre-training? Is a plain ViT too inefficient to use with high-resolution detection images?” (Li 等。, 2022, p. 1)</p><p>  如何应对下游任务的多尺寸对象？低效普通的ViT能够检测高分辨率图像？</p><p>  解决办法：将层级设计引入回backbone。</p><p>  相关研究：</p><p>  “Swin Transformers [40] and related works [53,16,32,28]”</p></li><li><p>第三-五段，引出自己的研究内容。</p><ol><li><p>提出设计:从独立上下游任务考虑，Figure 1右图为作者团队的设计：在最后一个特征图构建一个简单的金字塔neck。</p><p> 惊讶结论①：<strong>从单尺度特征图（没有常见的 FPN 设计）构建一个简单的特征金字塔就足够了；</strong></p><p> 惊讶结论②：<strong>使用窗口注意力（没有移位）就足够了跨窗口传播块</strong></p></li><li><p>效果优越，带有MAE效果更好。</p></li><li><p>展望</p></li></ol></li></ul><h2 id="三、相关工作"><a href="#三、相关工作" class="headerlink" title="三、相关工作"></a>三、相关工作</h2><ul><li>目标检测骨干网络</li><li>普通骨干网络的检测器</li><li>目标检测方法</li></ul><h2 id="四、方法介绍"><a href="#四、方法介绍" class="headerlink" title="四、方法介绍"></a>四、方法介绍</h2><p><em>研究目标</em>：删除backbone上的分层约束。做最小的微调适用于目标检测任务。</p><ul><li><p>简单的特征金字塔</p><ol><li><p><strong>仅从backbone最后一层的特征图，构建一个简单的特征金字塔</strong></p></li><li><p>“However, our scenario involves upsampling from a deep, lowresolution feature map, unlike [38], which taps into shallower feature maps. In hierarchical backbones, upsampling is often aided by lateral connection [35]; in plain ViT backbones, we empirically find this is not necessary (Sec. 4) and simple deconvolutions are sufficient.”</p><p> <strong>不需要自上而下的连接</strong></p></li><li><p>比较了两种种FPN变体(a)(b)</p><p> <img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220412143118054.png" alt="image-20220412143118054"></p><ul><li><ol><li>具体实现-&gt;在最后一个特征图上并行应用一组卷积或反卷积来生成多尺度特征图。具体来说，使用标准的ViT步长stride&#x3D;16，然后利用下采样卷积得到1&#x2F;32,1&#x2F;16的尺度特征图，利用反卷积操作得到1&#x2F;8,1&#x2F;4尺度特征图。</li></ol></li></ul></li></ol></li><li><p>骨干网络适应</p><p>  针对问题</p><p>  1、目标检测受益于高分辨率输入图像，但是这个又与在Transformer中全局计算自注意力存在矛盾，因为这样会变得更慢，并且占据很多内存。</p><p>  解决方法</p><p>  “We explore using window attention [52] with a few cross-window blocks. During fine-tuning, given a high-resolution feature map, we divide it into regular non-overlapping windows.5 Self-attention is computed within each window. This is referred to as “restricted ” self-attention in the original Transformer [52].” (Li 等。, 2022, p. 6)</p><p>  本文还采用几个跨窗口的模块来计算Window attention,对于给定高分辨率特征图我们将其划分为常规的非重叠窗口，在每个窗口内计算自注意力。</p><p>  与 Swin 不同，我们不会跨层“移动”窗口。为了允许信息传播，我们使用了极少数（默认情况下，4 个）可以传播的块。我们将预训练的主干网络平均分成 4 个块子集（例如，对于 24 块 ViT-L，每个子集中有 6 个）。我们在每个子集的最后一个块中应用传播策略。</p><ol><li><p>策略一：全局传播</p><p> 在每个子集的最后一个块中执行全局自我注意。由于全局块的数量很少，内存和计算成本是可行的。</p></li><li><p>策略二：卷积传播</p><p> 作为替代方案，我们在每个子集之后添加一个额外的卷积块。卷积块是一个残差块，由一个或多个卷积和一个恒等连接操作组成。该块中的最后一层被初始化为零，因此该块的初始状态是一个标记。将块初始化为身份允许我们将其插入到预训练主干中的任何位置，而不会破坏主干的初始状态。</p></li></ol></li><li><p>实现</p><ol><li>patch size &#x3D; 16*16</li><li>输入尺寸 1024*1024</li><li>AdamW优化器</li></ol></li></ul><h2 id="五、实验"><a href="#五、实验" class="headerlink" title="五、实验"></a>五、实验</h2><p>默认backbone情况是：vit+简单金字塔+全局传播（4个传播块）</p><p>预训练：backbone+MAE无标签在IN-1k上进行预训练</p><h3 id="实验一：证明简单金字塔是有效的"><a href="#实验一：证明简单金字塔是有效的" class="headerlink" title="实验一：证明简单金字塔是有效的"></a>实验一：证明简单金字塔是有效的</h3><p>消融对比试验，baseline是没有金字塔，abc分别对应上面三种图的情况。实验结果表明作者提出的简单金字塔效果最好。</p><h3 id="实验二：证明窗口注意仅需很少的传播块"><a href="#实验二：证明窗口注意仅需很少的传播块" class="headerlink" title="实验二：证明窗口注意仅需很少的传播块"></a>实验二：证明窗口注意仅需很少的传播块</h3><p>backbone适应消融实验</p><p>(a)不同的跨窗口交互策略：无、4个全局传播块、<strong>4个卷积传播块</strong>、移位窗口</p><p>(b)探究了不同类型的卷积块应用于卷积传播【<strong>basic two 3x*3;*</strong> bottleneck 1x1-&gt;3x3-&gt;1x1; naive 一个1x1卷积 】</p><p>(c)探究跨窗口传播应该位于骨干网络的哪个位置。【放在最前面4个块；放在最后4个块；<strong>4个全局传播块均匀的放位置。</strong>】</p><p>(d)探究使用的全局传播的块数</p><h3 id="实验三：“Comparisons-of-plain-vs-hierarchical-backbones”"><a href="#实验三：“Comparisons-of-plain-vs-hierarchical-backbones”" class="headerlink" title="实验三：“Comparisons of plain vs. hierarchical backbones”"></a>实验三：“Comparisons of plain vs. hierarchical backbones”</h3><p>金字塔Backbone对比</p><h3 id="实验四：与其他分层结构的backbone比较"><a href="#实验四：与其他分层结构的backbone比较" class="headerlink" title="实验四：与其他分层结构的backbone比较"></a>实验四：与其他分层结构的backbone比较</h3><h2 id="总结-amp-感悟"><a href="#总结-amp-感悟" class="headerlink" title="总结&amp;感悟"></a>总结&amp;感悟</h2><p>videt还是想解耦预训练和检测</p><ol><li><p>继承了来自<strong>YOLOF</strong>去掉FPN的思考，这次的<strong>ViTDet</strong>选择了直接暴力抹掉<strong>shift window</strong>，一步到位。</p></li><li><p>训练空间还是挺夸张的，不适合小老百姓的使用。采用MAE来无监督预训练，所以论文看起来简单，但是也只有大厂能烧的起实验。感觉这更多是一种工程化的探索，以及对于MAE的一次推广吧，所以读一读就可，深入研究的话，可能不一定能够跑得起来。</p></li><li><p>关于论文，有点不清不楚，怎么分成子集？平行训练？如果要更改结构预训练权重能否迁移？会不会效果不好？</p></li><li><p>只能说东一个大致更改的位置，但是对于细节不明不白。。。</p></li><li><p>尚未开源</p></li><li><p>yolof论文证明了FPN多尺度是没有用的。居然没引用。</p></li><li><p>一个证明，拿Swin来做backbone的话，window size的self-attention就够了，没有必要用shift，用一个普通的带shortcut的卷积来代替shift操作就行了。就是attention+convolution效果极好。</p></li><li><p>一个有意思的点：该论文中<code>Window attention + global propagation block</code>的设定和 <code>Transformer in Transformer</code> 的思路是一致的。</p><blockquote><p><strong>Window attention &#x3D;&#x3D; inner transformer</strong><br><strong>global propagation block &#x3D;&#x3D; outer transformer</strong><br><a href="https://arxiv.org/abs/2103.00112">https://arxiv.org/abs/2103.00112</a></p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MAE</title>
    <link href="/2022/04/11/MAE/"/>
    <url>/2022/04/11/MAE/</url>
    
    <content type="html"><![CDATA[<h1 id="MAE"><a href="#MAE" class="headerlink" title="MAE"></a>MAE</h1><h2 id="与之前的Transformer有什么区别？"><a href="#与之前的Transformer有什么区别？" class="headerlink" title="与之前的Transformer有什么区别？"></a>与之前的Transformer有什么区别？</h2><p>Transformer</p><p>Bert：NLP领域，相当于把一些词挖掉，在训练模型做完形填空</p><p>ViT</p><p>MAE：可以看作是一个将Bert拓展到CV</p><h2 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h2><ul><li>auto指的是“自”的意思，标号是图片自己本身</li><li>scalable：规模大（efficient来形容速度快）</li></ul><h2 id="二、摘要"><a href="#二、摘要" class="headerlink" title="二、摘要"></a>二、摘要</h2><p>“we develop an asymmetric encoder-decoder architecture, with an encoder that operates only on the visible subset of patches (without mask tokens), along with a lightweight decoder that reconstructs the original image from the latent representation and mask tokens. Second, we find that masking a high proportion of the input image, e.g., 75%, yields a nontrivial and meaningful self-supervisory task.” (He 等。, 2021, p. 1)</p><ul><li>设计一个非对称的encoder-decoder</li><li>编码器只作用于可见的patch中</li><li>如果遮住了较多部分如75%，那么他会得到一个非显然的而且有意义的自监督的任务</li></ul><p>“Transfer performance in downstream tasks outperforms supervised pretraining and shows promising scaling behavior.” (He 等。, 2021, p. 1)</p><p>该研究主要是用来做迁移学习的。</p><h2 id="三、关键图"><a href="#三、关键图" class="headerlink" title="三、关键图"></a>三、关键图</h2><p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220411184342734.png" alt="image-20220411184342734"></p><ul><li>灰色，表示盖住</li><li>没有被盖住的拿出来，放入encoder（ViT）：主要计算量来自于编码器</li><li>得到每一个块对应的特征</li><li>把被盖住的块，重新放回原来的位置（原始图拉成了一个向量）</li><li>输入到解码器decoder</li><li>解码器重构原来的信息</li></ul><p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220411181112127.png" alt="image-20220411181112127"></p><p>第一列是打了mask  第二列是重构  第三列是原图</p><p><img src="https://fsq.oss-cn-hangzhou.aliyuncs.com/image-20220411181141648.png" alt="image-20220411181141648"></p><p>mask不同比例的演示效果</p><h2 id="四、引言"><a href="#四、引言" class="headerlink" title="四、引言"></a>四、引言</h2><p><em>研究问题</em></p><ul><li>是什么让自编码mask在视觉和语言领域效果不同？</li></ul><p><em>对应提出观点</em></p><ol><li>CV通常使用卷积扫来扫去，卷积窗口很难区分边界，最后难还原</li><li>信息的密度有点不一样，图片信息冗余，可能可以通过插值插回来</li><li>在视觉中，解码器仅仅使用一个MLP是不够的</li></ol><p><strong>写作手法</strong></p><p>提问题-回答问题-引导出创新</p><p>以这样的结构是来解释为什么要设计成这个样子的原因讲清楚了</p><h2 id="五、相关工作"><a href="#五、相关工作" class="headerlink" title="五、相关工作"></a>五、相关工作</h2><ul><li>“Masked language modeling”</li><li>“Autoencoding”</li><li>“Masked image encoding”</li><li>“Self-supervised learning”</li></ul><h2 id="六、方法"><a href="#六、方法" class="headerlink" title="六、方法"></a>六、方法</h2><p>干货章节</p><ol><li><p>介绍掩码是怎么工作的</p><p> 只采样少量的块</p></li><li><p>MAE encoder 和ViT 差不多</p><p> 被mask的就不传入了</p></li><li><p>MAE decoder（主要作用做在预训练的时候）</p><p> 其实就是另外一个transformer</p></li><li><p>怎么样重构出原来的像素</p></li><li><p>简单实现</p><ul><li>首先生成token列，做一次线性投影，再加上位置信息</li><li>把这个序列随机打乱一下，把最后一块拿掉（相当于打乱之后保留前面25%，后面的丢掉）【随机采样】</li><li>在解码的时候要在后面附上跟之前长度一样的mask的patches</li><li>重新unshuffle一下</li></ul></li></ol><h2 id="七、实验"><a href="#七、实验" class="headerlink" title="七、实验"></a>七、实验</h2><ol><li><p>ImageNet上的实验</p><p> “with strong regularization” 在之前ViT的论文中说需要一个比较大的数据集才能够得到好的效果，后来研究发现如果加入合适的正则项的话，其实在小一点的数据上也是能训练出来的。</p><ul><li>无监督的训练</li><li>有监督的训练</li></ul></li><li><p>各种消融实验（不同超参数）</p></li><li><p>比的是与其他方法比</p></li><li><p>局部微调【高层于自己的任务相关，最好调一调】</p></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li><p>简单算法？（主要是针对该领域的研究）</p><p> MAE基于ViT,ViT基于Transformer模型算法不会简单</p></li><li><p>效果可以媲美有标号的工作</p></li><li><p>潜在影响【类似于说GAN】,可能会有不存在的东西出现</p></li></ol><h2 id="个人思考："><a href="#个人思考：" class="headerlink" title="个人思考："></a>个人思考：</h2><p>1、嫁接这个创新点到我们自己的舞台数据集上</p><p>将图片打成patches,因为有关键点标签。可以将关键点所在的patches保留，其他图片块mask掉。</p><p>2、代码没有公布，用的是TensorFlow+TPU，小老百姓难嫁接</p><p>3、随机mask将重要信息mask了，是否应该选择性的mask?</p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
